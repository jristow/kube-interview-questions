## What is required to deploy a simple application, like a web server in Kubernetes? How would you go about deploying/updating your app?

This is a great question because there's a few layers that we can unpack here. Assuming the application source code is correct and everything runs, the basic requirement to deploy the application on kubernetes is a container image hosted in an image registry somewhere. With that image, we can create a deployment within kubernetes by running `kubectl create deployment nginx --image nginx`, using the publicly available nginx image for this example. After this, we can check out the pod that was generated by running `kubectl get pods` and we should see one

However, this pod is unable to be accessed by anyone outside of the kubernetes cluster. To make the application available, we then need to create a service, exposing the pod's port to external traffic. Again, we can create a service by running `kubectl create service nodeport nginx-service --tcp=80:8080`, which will generate a service that forwards external traffic on port 80, to the node's port 8080. If we set the pod to listen on port 8080,  people outside of our cluster can access our wicked awesome application.

This works great, until we need to update our application to a newer version. We should be able to simply go in and change our image to the latest version that is available. We can do this with a quick `kubectl edit nginx` and then changing the spec.containers.image value to our new image. Once we do that, our pod restarts using the new image we defined.

This process gets us a running application. However it is very manual and requires a lot of interacting with the command line of our cluster. Which makes it difficult to track changes and do root cause analysis when problems arise. A better way to create these deployments and services is by creating yaml files detailing what we want to create and then applying them in our cluster which will handle creating our pods and services. We can then put these yaml files into source control, like git, and utilize CI/CD pipelines to update our applications with much less manual intervention.